# -*- coding: utf-8 -*-
"""
Created on Sat Jun 11 18:25:39 2022

@author: Berno
"""

import cvxpy as cp
import numpy as np
import itertools
import pathlib
import json
import matplotlib.pyplot as plt



"""
PROBLEM DATA:

We grab the basic information from the json file and construct
    nodes (list)
    edges (list)
    currentLiquidity (dict)
    scaledLiquidity (dict)
    weights (dict)

currentLiquidity dictionary does not have a pool for each pair.
scaledLiquidity dicitionary scales values in currentLiquidity dictionary
    by the totalLiquidity in all pools together.
    
weights are based on the counted number of trades of a certain size and pair
    and are normalized by the total number of trades of any size and pair
"""

# config file is generated by getConfig.py
filename = 'config.json'
file = pathlib.Path(filename)

text = open(filename)
config = json.load(text)
    
n = config['size']
weights = config['weights']
reserves = config['reserves']


# Construct the rest of the problemdata
nodes = []
edges = []
currentLiquidity = {}
scaledLiquidity = {}

# Precision is for rounding in scaledLiquidities
precision = 4

# Fee is for the computation of the CPMM
fee = 0.003

for token1, token2 in itertools.permutations(weights, 2):
    nodes.append(token1)
    nodes.append(token2)
    edges.append((token1, token2))
    
nodes = list(set(nodes))

n = len(nodes)
m = len(edges)


# construct 'edge - reserve' dict
totalLiquidity = 0
for pool in reserves:
    if pool in currentLiquidity:
        currentLiquidity[(reserves[pool]['token0'], reserves[pool]['token1'])] += reserves[pool]['reserves']
        currentLiquidity[(reserves[pool]['token1'], reserves[pool]['token0'])] += reserves[pool]['reserves']
    else:
        currentLiquidity[(reserves[pool]['token0'], reserves[pool]['token1'])] = reserves[pool]['reserves']
        currentLiquidity[(reserves[pool]['token1'], reserves[pool]['token0'])] = reserves[pool]['reserves']

    if (reserves[pool]['token0'], reserves[pool]['token1']) in edges:
        totalLiquidity += reserves[pool]['reserves']

for pool in edges:
    if pool in currentLiquidity:
        scaledLiquidity[pool] = round(currentLiquidity[pool]/totalLiquidity, precision)
    else:
        scaledLiquidity[pool] = 0


# construct weights dict
totTrades = 0
for token1, token2 in itertools.permutations(nodes, 2):
    buckets = weights[token1][token2]['buckets']
    for bucket in buckets:
        totTrades += buckets[bucket]['count']
        
for token1, token2 in itertools.permutations(nodes, 2):
    for bucket in buckets:
        weights[token1][token2]['buckets'][bucket]['count'] /= totTrades
    

"""
ADDITIONAL TOOLS:

Degree Matrices are used to construct problem instance.

"""

# Degree Matrices
# Used in the constraints to sum over variables that represent pools containing a given currency
sum_all = {}
for token in nodes:
    sum_all_token = np.zeros((2,m), dtype=int)

    for i in range(m):
        if token == edges[i][0]:
            sum_all_token[0][i] = 1
            
        elif token == edges[i][1]:
            sum_all_token[1][i] = 1

    sum_all[token] = sum_all_token



"""
CONSTRUCTING THE PROBLEM:
    
We construct variables for pool levels before routing (old) and 
    for pool levels after routing from x to y (new[x][y]).
    
The objective function and constraints are also created in this section.

"""

# Parameter
liquidity = cp.Parameter((m, 1), nonneg=True, name='prerouting liquidity')

# Variables
new = {}
arrived_liquidity = {}
for token1 in nodes:
    new[token1] = {}
    arrived_liquidity[token1] = {}
    for token2 in nodes:
        if token1 != token2:
            new[token1][token2] = {}
            arrived_liquidity[token1][token2] = {}
            for bucket in buckets:
                new[token1][token2][bucket] = cp.Variable((m,2), nonneg=True, name='postrouting liquidity')
                arrived_liquidity[token1][token2][bucket] = cp.Variable(nonneg=True, name='arrived liqudity')


# Objective
objective_expression = 0
for start, goal in itertools.permutations(nodes, 2):
    for bucket in buckets:
        objective_expression += weights[start][goal]['buckets'][bucket]['count'] * arrived_liquidity[start][goal][bucket]

objective = cp.Maximize(objective_expression)


# Constraints
constraints = []

for start, goal in itertools.permutations(nodes, 2):
    for bucket in buckets:
        
        for token in nodes:
            if token == start:
                # Inserted Liquidity Constraint
                constraints += [
                    cp.trace(sum_all[token] @ (new[start][goal][bucket] - liquidity)) == buckets[bucket]['tradesize']/totalLiquidity
                ]
            
            elif token == goal:
                # Removed Liquidity Constraint
                constraints += [
                    cp.trace(sum_all[token] @ (new[start][goal][bucket] - liquidity)) == (-1)*arrived_liquidity[start][goal][bucket]
                ]
            
            else:
                # Preserved Liquidity Constraint
                constraints += [
                    cp.trace(sum_all[token] @ (new[start][goal][bucket] - liquidity)) == 0
                ]
                

        for i in range(m):
            # Constant Product Constraint
            constraints += [
                liquidity[i, 0] <= cp.geo_mean(
                    cp.hstack(
                        [fee * liquidity[i, 0] + (1-fee) * new[start][goal][bucket][i, 0],
                         new[start][goal][bucket][i, 1]]
                    )
                )
            ]

            # First coordinate of a pool is the increasing currency
            constraints += [
                liquidity[i, 0] - new[start][goal][bucket][i, 0] <= 0
            ]


prob = cp.Problem(objective, constraints)




"""
START SOLVING

We do a simple gradient descent where we move a 'delta' unit of $$ between
the two pools with the best improvement until we plateau.

"""

accuracy = 1e-8
maxIterations = 10000000
averageTrades = []

npLiquidity = np.zeros((m,1))
for i in range(m):
    npLiquidity[i,0] = scaledLiquidity[edges[i]]
    
liquidity.value = npLiquidity

averageTrade = prob.solve(solver='SCS', verbose=False, max_iters=maxIterations, eps=accuracy)
    
averageInput = 0
for token1 in nodes:
    for token2 in nodes:
        buckets = weights[token1][token2]['buckets']
        for bucket in buckets:
            averageInput += buckets[bucket]['count'] * buckets[bucket]['tradesize']    

print('average input:\t', averageInput)
print('average trade:\t', averageTrade*totalLiquidity)

print('tokens:')
for node in nodes:
    print('\t', weights[node]['symb'])
    

plotPools = []
plotLiq = []
for (x,y) in scaledLiquidity:
    if not str((weights[y]['symb'], weights[x]['symb'])) in plotPools:
        plotPools.append(str((weights[x]['symb'], weights[y]['symb'])))
        plotLiq.append(scaledLiquidity[(x,y)])
        
plt.bar(plotPools, plotLiq)
plt.xticks(rotation='vertical')
plt.xlabel('current configuration')
plt.ylabel('level')
plt.show()